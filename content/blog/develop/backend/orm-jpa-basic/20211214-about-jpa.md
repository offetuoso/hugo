---
title: "[자바 ORM 표준 JPA] JPA 소개"
image: "bg-jpa.png"
font_color: "white"
font_size: "28px"
opacity: "0.4"
date: 2021-12-14
slug: "about-jpa"
description: "JPA 소개"	
keywords: ["Restful"]
draft: false
categories: ["RESTful"]
tags: ["Java","JPA","ORM", "인프런", "김영한", "자바 ORM 표준 JPA"]
math: false
toc: true
---


# JPA

## 애플리케이션
> 지금 시대는 <mark>객체</mark>를 <mark>관계형 DB</mark>에 관리 <br>
> 객체 지향 언어를 사용한 프로젝트라고 하여도 결국엔 SQL이 제일 중요할 수 밖에 없다. <br>
> 관계형 DB가 알아 들을 수 있는 것은 SQL이니까

## SQL 중심적인 개발의 문제점 
> - 무한 반복, 지루한 코드

### CRUD
> - INSERT
> - UPDATE
> - SELECT
> - DELETE
> - 자바 객체를 SQL로 .. 
> - SQL을 자바 객체로 ..


### 객체 CRUD
> 간단히 Member라는 객체를 생성하고, sql로 CRUD를 개발하였다고 생각하자.

```
public class Member {
	private String memberId;
	private String name;
	...
}
 
 /*
 	INSERT INTO MEMBER(MEMBER_ID, NAME) VALUES
	SELECT MEMBER_ID, NAME FROM MEMBER M
	UPDATE MEMBER SET … 
 */
```

### 객체 CRUD - 필드추가
> 개발이 끝났을때, 기획에서 연락처를 추가해 달라는 요청이 왔다

```
public class Member {
	private String memberId;
	private String name;
	
	/* 신규추가 tel */
	private String tel; 
	
	...
}
 
 /*
 	INSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUES -- 신규추가 tel
	SELECT MEMBER_ID, NAME, TEL FROM MEMBER M  -- 신규추가 tel
	UPDATE MEMBER SET …  , TEL = ?  -- 신규추가 tel
 */
```

## SQL에 의존적인 개발을 피하기 어렵다.
> 관계형 DB를 사용하는 이상 SQL에 의존적이며, DB의 테이블 또는 컬럼에 따라 SQL을 계속 수정하고 작성하게 되어있다.

## 패러다임의 불일치
>  관계형 데이터베이스의 사상과 객체 지향의 사상이 매우 다름
### 객체 VS 관계형 데이터베이스

#### 관계형 데이터베이스
> 데이터를 잘 정규화 해서 보관

#### 객체 
> 속성과 기능을 묶어서 캡슐화 하여 객체간 유기적으로 사용

### 객체를 영구 보관하는 다양한 저장소
> - RDB
> - NoSql
> - File 
> - etc

> 현실적 대안은 RDB 


#### 객체를 관계형 데이터베이스에 저장

> 객체 -> SQL 변환 -> RDB <br>

> 이렇게 객체를 SQL로 변환하여 주는 업무를 개발자가 한다.  <br>
> 출근해서 SQL을 하루종일 작성하고 있는것이.. SQL 매퍼의 일을 개발자가 하고 있다.


### 객체와 관계형 데이터베이스의 차이
> - 상속 
> 객체의 상속관계 같은 것은 없고 유사한 것은 있지만, 없다고 본다. <br>

> - 연관관계
> 객체 참조와 RDB의 PK, FK를 이용해 조인하여 연관관계를 찾을 수 있음 <br>

> - 데이터 타입 
> - 데이터 식별 방법


#### 상속
![contact](/images/develop/backend/orm-jpa-basic/about-jpa/img-2.png)


##### Album 저장
> 1. 객체 분해
> 2. INSERT INTO ITEM ...
> 3. INSERT INTO ALBUM ..



##### Album 조회

> 1. 각각의 테이블에 따른 조인 SQL 작성
> 2. 상속 관계에 따라 각각 객체 생성
> 3. SQL 조회결과에 따라 각각 객체에 데이터 세팅.. 등 복잡
> 4. 그래서 DB에 저장할 객체에는 상속 관계 안쓴다

##### 자바 컬렉션에 저장하면?
> 객체를 담을 수 있는 특별한 컬렉션이 있다고 가정하면 !

```
list.add(album);
```

##### 자바 컬렉션에서 조회하려면?

```
Album album = list.get(albumId);

//보모 타입으로 조회 후 다형성 활용
Item item = list.get(albumId);
```

> 컬렉션에 넣고 빼는 것은 심플하지만, 관계형 DB에 넣고 빼는 순간 중간에서 SQL 매핑작업을 개발자가 
손수 작업을 해줘야 한다.


#### 연관관계
> - 객체는 참조를 사용 : member.getTeam()
> - 테이블은 외래 키를 사용 : JOIN ON M.TEAM_ID = T.TEAM_ID


![contact](/images/develop/backend/orm-jpa-basic/about-jpa/img-3.png)


#### 객체를 테이블에 맞추어 모델링

```
class Member {
	Long id; 			// MEMBER_ID 컬럼 사용
	Long teamId;		// TEAM_ID FK 컬럼 사용
	String username;   // USERNAME 컬럼 사용
}

class Team {
	Long id;		// TEAM_ID PK 사용
	String name;  // NAME 컬럼 사용
}
```

##### 테이블에 맞춘 객체 저장

![contact](/images/develop/backend/orm-jpa-basic/about-jpa/img-4.png)


#### 객체다운 모델링

```
class Member {
	Long id; 			// MEMBER_ID 컬럼 사용
	Team team;		// 참조로 연관관계를 맺는다.
	String username;   // USERNAME 컬럼 사용
	
	Team getTeam(){
		return team;
	}
}

class Team {
	Long id;		// TEAM_ID PK 사용
	String name;  // NAME 컬럼 사용
}
```

##### 객체 모델링 저장 

![contact](/images/develop/backend/orm-jpa-basic/about-jpa/img-5.png)


##### 객체 모델링 조회

```
--select.member.info
SELECT M.*, T.*
  FROM MEMBER M
  JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
  

public Member find(Long memberId){
	
	// SQL 실행
	Map result = sql.executeQuery("select.member.info");

	// 데이터베이스에서 조회한 회원 관련 정보 세팅
	Meber member = new Member();
	member.set("id", result.get("id"));
	...
	...
	
	// 데이터베이스에서 조회한 팀관련 정보를 모두 입력
	Team team = new Team();
	team.set("id", result.get("teamId"));
	...
	...
	
	// 회원과 팀 관계 설정
	member.setTeam(team);
	
	// 회원 객체 반환
	return member;
}

```

> 이러한 번잡함을 해결하기 위해 Meber와 Team을 모두 포괄하는 SuperDto(MemberTeamDto) 등 으로 한번에 받음



 #### 객체 모델링, 자바 컬렉션에 관리
 
```
 list.add(member);
 
 Member member = list.get(memberId);
 Team team = member.getTeam();
```

> 자바 컬렉션에 넣는다고 생각하면 이러한 형태가 객체지향적으로 설계하기 괜찮음

##### 객체 그래프 탐색 
> 객체는 자유롭게 객체 그래프를 탐색 할 수 있어야 한다.

![contact](/images/develop/backend/orm-jpa-basic/about-jpa/img-6.png)


##### 처음 실행하는 SQL에 따라 탐색 범위 결정

```
--select.member.info
SELECT M.*, T.*
  FROM MEMBER M
  JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

member.getTema()  //OK
member.getOrder() // null
```
> 조회한 sql에 따라 order 테이블엔 값이 있어도 sql에서 order를 조회 하지 않았기 때문에 
getOrder()에서는 null이 발생

##### 엔티티 신뢰 문제
```
class meberService {
	
	...
	public void process(){
		Member member = memberDAO.find(memberId);
		member.getTeam();	// ???
		member.getOrder().getDelivery(); // ???
	}

}
```

> 누군가 개발해둔 소스를 보고 Meamber를 조회하고, getTeam과 getOrder로 Team과 Order를 사용하면 되겠다 생각이 들겠지만,  <br>
실제로 memberDAO.find()를 열어서 실제 조회하는 sql을 확인하고 내부동작이 어떻게 되어있는지 확인 하지 않는 이상 어떤 결과가 있을지 모른다. <br>
이러한 계층구조 객체를 레이어드 아키텍처라 하는데, 레이어드 아키텍처는 다음 레이어에서 신뢰하고 사용을 할 수 있어야 한다. 하지만  이경우 엔티티 신뢰 문제가 발생.

##### 모든 객체를 미리 로딩할 수는 없다.
> 상황에 따라 동일한 회원 조회 메서드를 여러벌 생성

```
memberDAO.getMember(); // Member만 조회

memberDAO.getMemberWithTeam(); // Member와 Team 조회

// Member, Team, Delivery 조회
memberDAO.getMemberWithTeamWithDelivery(); 

```

#### 계층형 아키텍처
> 진정한 의미의 계층 분할이 어렵다.


### 비교하기

#### 비교하기 - 자바 객체로 조회
```
String memberId = "100";
Member member1 = memberDAO.getMember(memberId); 
Member member2 = memberDAO.getMember(memberId);

member1 == member2; //다르다. (getMember에서 sql로 조회된 데이터는 같아도 return되는 객체는 new로 새로 만들기 때문에 다름)

class MemberDAO {
 
	 public Member getMember(String memberId) {
		 String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
		 ...
		 //JDBC API, SQL 실행
		 return new Member(...); //객체를 새로만듬
	 }
}

```

#### 비교하기 - 자바 컬렉션에서 조회
> 이러한 특수한 컬렉션이 있다고 가정


```
String memberId = "100";
Member member1 = list.get(memberId);
Member member2 = list.get(memberId);

member1 == member2; //같다. (참조 값이 같다)

```

> sql에서 다룰때랑, 자바 컬렉션에서 다룰때랑, 자바 객체에서 다룰때, 관계형 DB에서 다룰때 중간에 많은 믹스매치가 발생

### 객체답게 모델링 할수록 매핑 작업만 늘어난다.
> 객체지향을 배우고 객체지향을 토대로 설계하고 구현할 경우 번잡한 매핑 작업만 들어난다. <br>
> 그래서 sql에 맞춰서 데이터 전송하는 객체로 만들 수 밖에 없음. (만들 수 있지만, 개발 퍼포먼스 측면에서 지옥이다.)


### 객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수 없을까
> 1980 년대 부터 많은 개발자들이 고민을 해왔다고합니다. 자바 진영에서는 그 고민의 결과 !

##  JPA - Java Persistence API

 

### 참고
> - <a href="https://www.inflearn.com/course/ORM-JPA-Basic">자바 ORM 표준 JPA</a>
